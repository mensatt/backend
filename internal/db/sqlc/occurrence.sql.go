// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: occurrence.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createOccurrence = `-- name: CreateOccurrence :one
INSERT INTO occurrence (location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
`

type CreateOccurrenceParams struct {
	Location      uuid.UUID        `json:"location"`
	Dish          uuid.UUID        `json:"dish"`
	Date          time.Time        `json:"date"`
	Status        OccurrenceStatus `json:"status"`
	Kj            sql.NullInt32    `json:"kj"`
	Kcal          sql.NullInt32    `json:"kcal"`
	Fat           sql.NullInt32    `json:"fat"`
	SaturatedFat  sql.NullInt32    `json:"saturated_fat"`
	Carbohydrates sql.NullInt32    `json:"carbohydrates"`
	Sugar         sql.NullInt32    `json:"sugar"`
	Fiber         sql.NullInt32    `json:"fiber"`
	Protein       sql.NullInt32    `json:"protein"`
	Salt          sql.NullInt32    `json:"salt"`
	PriceStudent  sql.NullInt32    `json:"price_student"`
	PriceStaff    sql.NullInt32    `json:"price_staff"`
	PriceGuest    sql.NullInt32    `json:"price_guest"`
}

func (q *Queries) CreateOccurrence(ctx context.Context, arg *CreateOccurrenceParams) (*Occurrence, error) {
	row := q.db.QueryRow(ctx, createOccurrence,
		arg.Location,
		arg.Dish,
		arg.Date,
		arg.Status,
		arg.Kj,
		arg.Kcal,
		arg.Fat,
		arg.SaturatedFat,
		arg.Carbohydrates,
		arg.Sugar,
		arg.Fiber,
		arg.Protein,
		arg.Salt,
		arg.PriceStudent,
		arg.PriceStaff,
		arg.PriceGuest,
	)
	var i Occurrence
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.Dish,
		&i.Date,
		&i.Status,
		&i.Kj,
		&i.Kcal,
		&i.Fat,
		&i.SaturatedFat,
		&i.Carbohydrates,
		&i.Sugar,
		&i.Fiber,
		&i.Protein,
		&i.Salt,
		&i.PriceStudent,
		&i.PriceStaff,
		&i.PriceGuest,
	)
	return &i, err
}

const deleteOccurrence = `-- name: DeleteOccurrence :one
DELETE FROM occurrence
WHERE id = $1
RETURNING id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
`

func (q *Queries) DeleteOccurrence(ctx context.Context, id uuid.UUID) (*Occurrence, error) {
	row := q.db.QueryRow(ctx, deleteOccurrence, id)
	var i Occurrence
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.Dish,
		&i.Date,
		&i.Status,
		&i.Kj,
		&i.Kcal,
		&i.Fat,
		&i.SaturatedFat,
		&i.Carbohydrates,
		&i.Sugar,
		&i.Fiber,
		&i.Protein,
		&i.Salt,
		&i.PriceStudent,
		&i.PriceStaff,
		&i.PriceGuest,
	)
	return &i, err
}

const getAllOccurrences = `-- name: GetAllOccurrences :many
SELECT id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
FROM occurrence
`

func (q *Queries) GetAllOccurrences(ctx context.Context) ([]*Occurrence, error) {
	rows, err := q.db.Query(ctx, getAllOccurrences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Dish,
			&i.Date,
			&i.Status,
			&i.Kj,
			&i.Kcal,
			&i.Fat,
			&i.SaturatedFat,
			&i.Carbohydrates,
			&i.Sugar,
			&i.Fiber,
			&i.Protein,
			&i.Salt,
			&i.PriceStudent,
			&i.PriceStaff,
			&i.PriceGuest,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredOccurrences = `-- name: GetFilteredOccurrences :many
SELECT id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
FROM occurrence
WHERE
    (date >= $1 OR $1 IS NULL)
    AND (date <= $2 OR $2 IS NULL)
    AND (location = $3 OR $3 IS NULL)
    AND (status = $4 OR $4 IS NULL)
`

type GetFilteredOccurrencesParams struct {
	StartDate sql.NullTime         `json:"startDate"`
	EndDate   sql.NullTime         `json:"endDate"`
	Location  uuid.NullUUID        `json:"location"`
	Status    NullOccurrenceStatus `json:"status"`
}

func (q *Queries) GetFilteredOccurrences(ctx context.Context, arg *GetFilteredOccurrencesParams) ([]*Occurrence, error) {
	rows, err := q.db.Query(ctx, getFilteredOccurrences,
		arg.StartDate,
		arg.EndDate,
		arg.Location,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Dish,
			&i.Date,
			&i.Status,
			&i.Kj,
			&i.Kcal,
			&i.Fat,
			&i.SaturatedFat,
			&i.Carbohydrates,
			&i.Sugar,
			&i.Fiber,
			&i.Protein,
			&i.Salt,
			&i.PriceStudent,
			&i.PriceStaff,
			&i.PriceGuest,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesForOccurrence = `-- name: GetImagesForOccurrence :many
SELECT image.id, image.image_hash, image.review
FROM occurrence
JOIN review ON (occurrence.id = review.occurrence)
JOIN image ON (review.id = image.review)
WHERE occurrence.id = $1
`

func (q *Queries) GetImagesForOccurrence(ctx context.Context, id uuid.UUID) ([]*Image, error) {
	rows, err := q.db.Query(ctx, getImagesForOccurrence, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(&i.ID, &i.ImageHash, &i.Review); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOccurrenceByID = `-- name: GetOccurrenceByID :one
SELECT id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest 
FROM occurrence
WHERE id = $1
`

func (q *Queries) GetOccurrenceByID(ctx context.Context, id uuid.UUID) (*Occurrence, error) {
	row := q.db.QueryRow(ctx, getOccurrenceByID, id)
	var i Occurrence
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.Dish,
		&i.Date,
		&i.Status,
		&i.Kj,
		&i.Kcal,
		&i.Fat,
		&i.SaturatedFat,
		&i.Carbohydrates,
		&i.Sugar,
		&i.Fiber,
		&i.Protein,
		&i.Salt,
		&i.PriceStudent,
		&i.PriceStaff,
		&i.PriceGuest,
	)
	return &i, err
}

const getOccurrencesAfterInclusiveDate = `-- name: GetOccurrencesAfterInclusiveDate :many
SELECT id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
FROM occurrence
WHERE date >= $1
`

func (q *Queries) GetOccurrencesAfterInclusiveDate(ctx context.Context, date time.Time) ([]*Occurrence, error) {
	rows, err := q.db.Query(ctx, getOccurrencesAfterInclusiveDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Dish,
			&i.Date,
			&i.Status,
			&i.Kj,
			&i.Kcal,
			&i.Fat,
			&i.SaturatedFat,
			&i.Carbohydrates,
			&i.Sugar,
			&i.Fiber,
			&i.Protein,
			&i.Salt,
			&i.PriceStudent,
			&i.PriceStaff,
			&i.PriceGuest,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOccurrencesByDate = `-- name: GetOccurrencesByDate :many
SELECT id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
FROM occurrence
WHERE date = $1
`

func (q *Queries) GetOccurrencesByDate(ctx context.Context, date time.Time) ([]*Occurrence, error) {
	rows, err := q.db.Query(ctx, getOccurrencesByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Dish,
			&i.Date,
			&i.Status,
			&i.Kj,
			&i.Kcal,
			&i.Fat,
			&i.SaturatedFat,
			&i.Carbohydrates,
			&i.Sugar,
			&i.Fiber,
			&i.Protein,
			&i.Salt,
			&i.PriceStudent,
			&i.PriceStaff,
			&i.PriceGuest,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForOccurrence = `-- name: GetTagsForOccurrence :many
SELECT tag.key, tag.name, tag.description, tag.short_name, tag.priority, tag.is_allergy
FROM occurrence_tag JOIN tag ON (occurrence_tag.tag = tag.key)
WHERE occurrence_tag.occurrence = $1
`

func (q *Queries) GetTagsForOccurrence(ctx context.Context, occurrence uuid.UUID) ([]*Tag, error) {
	rows, err := q.db.Query(ctx, getTagsForOccurrence, occurrence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.Key,
			&i.Name,
			&i.Description,
			&i.ShortName,
			&i.Priority,
			&i.IsAllergy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeOccurrences = `-- name: MergeOccurrences :exec
UPDATE occurrence
SET dish = $1
WHERE dish = $2
`

type MergeOccurrencesParams struct {
	Keep  uuid.UUID `json:"keep"`
	Merge uuid.UUID `json:"merge"`
}

func (q *Queries) MergeOccurrences(ctx context.Context, arg *MergeOccurrencesParams) error {
	_, err := q.db.Exec(ctx, mergeOccurrences, arg.Keep, arg.Merge)
	return err
}

const mergeSameDayOccurrences = `-- name: MergeSameDayOccurrences :exec
DELETE
FROM occurrence
WHERE id IN (
    SELECT o2.id
    FROM occurrence o1
    JOIN occurrence o2 ON o1.date = o2.date
    WHERE o1.dish = $1
    AND o2.dish = $2
)
`

type MergeSameDayOccurrencesParams struct {
	Keep  uuid.UUID `json:"keep"`
	Merge uuid.UUID `json:"merge"`
}

func (q *Queries) MergeSameDayOccurrences(ctx context.Context, arg *MergeSameDayOccurrencesParams) error {
	_, err := q.db.Exec(ctx, mergeSameDayOccurrences, arg.Keep, arg.Merge)
	return err
}

const updateOccurrence = `-- name: UpdateOccurrence :one
UPDATE occurrence
SET 
    dish = COALESCE($2, dish),
    date = COALESCE($3, date),
    status = COALESCE($4, status),
    kj = COALESCE($5, kj),
    kcal = COALESCE($6, kcal),
    fat = COALESCE($7, fat),
    saturated_fat = COALESCE($8, saturated_fat),
    carbohydrates = COALESCE($9, carbohydrates),
    sugar = COALESCE($10, sugar),
    fiber = COALESCE($11, fiber),
    protein = COALESCE($12, protein),
    salt = COALESCE($13, salt),
    price_student = COALESCE($14, price_student),
    price_staff = COALESCE($15, price_staff),
    price_guest = COALESCE($16, price_guest)
WHERE id = $1
RETURNING id, location, dish, date, status, kj, kcal, fat, saturated_fat, carbohydrates, sugar, fiber, protein, salt, price_student, price_staff, price_guest
`

type UpdateOccurrenceParams struct {
	ID            uuid.UUID            `json:"id"`
	Dish          uuid.NullUUID        `json:"dish"`
	Date          sql.NullTime         `json:"date"`
	Status        NullOccurrenceStatus `json:"status"`
	Kj            sql.NullInt32        `json:"kj"`
	Kcal          sql.NullInt32        `json:"kcal"`
	Fat           sql.NullInt32        `json:"fat"`
	SaturatedFat  sql.NullInt32        `json:"saturated_fat"`
	Carbohydrates sql.NullInt32        `json:"carbohydrates"`
	Sugar         sql.NullInt32        `json:"sugar"`
	Fiber         sql.NullInt32        `json:"fiber"`
	Protein       sql.NullInt32        `json:"protein"`
	Salt          sql.NullInt32        `json:"salt"`
	PriceStudent  sql.NullInt32        `json:"price_student"`
	PriceStaff    sql.NullInt32        `json:"price_staff"`
	PriceGuest    sql.NullInt32        `json:"price_guest"`
}

func (q *Queries) UpdateOccurrence(ctx context.Context, arg *UpdateOccurrenceParams) (*Occurrence, error) {
	row := q.db.QueryRow(ctx, updateOccurrence,
		arg.ID,
		arg.Dish,
		arg.Date,
		arg.Status,
		arg.Kj,
		arg.Kcal,
		arg.Fat,
		arg.SaturatedFat,
		arg.Carbohydrates,
		arg.Sugar,
		arg.Fiber,
		arg.Protein,
		arg.Salt,
		arg.PriceStudent,
		arg.PriceStaff,
		arg.PriceGuest,
	)
	var i Occurrence
	err := row.Scan(
		&i.ID,
		&i.Location,
		&i.Dish,
		&i.Date,
		&i.Status,
		&i.Kj,
		&i.Kcal,
		&i.Fat,
		&i.SaturatedFat,
		&i.Carbohydrates,
		&i.Sugar,
		&i.Fiber,
		&i.Protein,
		&i.Salt,
		&i.PriceStudent,
		&i.PriceStaff,
		&i.PriceGuest,
	)
	return &i, err
}
