// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/mensatt/backend/internal/database/ent/dish"
	"github.com/mensatt/backend/internal/database/ent/location"
	"github.com/mensatt/backend/internal/database/ent/occurrence"
)

// Occurrence is the model entity for the Occurrence schema.
type Occurrence struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// Date holds the value of the "date" field.
	Date time.Time `json:"date,omitempty"`
	// Kj holds the value of the "kj" field.
	Kj *int `json:"kj,omitempty"`
	// Kcal holds the value of the "kcal" field.
	Kcal *int `json:"kcal,omitempty"`
	// Fat holds the value of the "fat" field.
	Fat *int `json:"fat,omitempty"`
	// SaturatedFat holds the value of the "saturated_fat" field.
	SaturatedFat *int `json:"saturated_fat,omitempty"`
	// Carbohydrates holds the value of the "carbohydrates" field.
	Carbohydrates *int `json:"carbohydrates,omitempty"`
	// Sugar holds the value of the "sugar" field.
	Sugar *int `json:"sugar,omitempty"`
	// Fiber holds the value of the "fiber" field.
	Fiber *int `json:"fiber,omitempty"`
	// Protein holds the value of the "protein" field.
	Protein *int `json:"protein,omitempty"`
	// Salt holds the value of the "salt" field.
	Salt *int `json:"salt,omitempty"`
	// PriceStudent holds the value of the "price_student" field.
	PriceStudent *int `json:"price_student,omitempty"`
	// PriceStaff holds the value of the "price_staff" field.
	PriceStaff *int `json:"price_staff,omitempty"`
	// PriceGuest holds the value of the "price_guest" field.
	PriceGuest *int `json:"price_guest,omitempty"`
	// NotAvailableAfter holds the value of the "notAvailableAfter" field.
	NotAvailableAfter *time.Time `json:"notAvailableAfter,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the OccurrenceQuery when eager-loading is set.
	Edges        OccurrenceEdges `json:"edges"`
	dish         *uuid.UUID
	location     *uuid.UUID
	selectValues sql.SelectValues
}

// OccurrenceEdges holds the relations/edges for other nodes in the graph.
type OccurrenceEdges struct {
	// Location holds the value of the location edge.
	Location *Location `json:"location,omitempty"`
	// Dish holds the value of the dish edge.
	Dish *Dish `json:"dish,omitempty"`
	// Tags holds the value of the tags edge.
	Tags []*Tag `json:"tags,omitempty"`
	// SideDishes holds the value of the side_dishes edge.
	SideDishes []*Dish `json:"side_dishes,omitempty"`
	// Reviews holds the value of the reviews edge.
	Reviews []*Review `json:"reviews,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// LocationOrErr returns the Location value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OccurrenceEdges) LocationOrErr() (*Location, error) {
	if e.loadedTypes[0] {
		if e.Location == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: location.Label}
		}
		return e.Location, nil
	}
	return nil, &NotLoadedError{edge: "location"}
}

// DishOrErr returns the Dish value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OccurrenceEdges) DishOrErr() (*Dish, error) {
	if e.loadedTypes[1] {
		if e.Dish == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: dish.Label}
		}
		return e.Dish, nil
	}
	return nil, &NotLoadedError{edge: "dish"}
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e OccurrenceEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[2] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// SideDishesOrErr returns the SideDishes value or an error if the edge
// was not loaded in eager-loading.
func (e OccurrenceEdges) SideDishesOrErr() ([]*Dish, error) {
	if e.loadedTypes[3] {
		return e.SideDishes, nil
	}
	return nil, &NotLoadedError{edge: "side_dishes"}
}

// ReviewsOrErr returns the Reviews value or an error if the edge
// was not loaded in eager-loading.
func (e OccurrenceEdges) ReviewsOrErr() ([]*Review, error) {
	if e.loadedTypes[4] {
		return e.Reviews, nil
	}
	return nil, &NotLoadedError{edge: "reviews"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Occurrence) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case occurrence.FieldKj, occurrence.FieldKcal, occurrence.FieldFat, occurrence.FieldSaturatedFat, occurrence.FieldCarbohydrates, occurrence.FieldSugar, occurrence.FieldFiber, occurrence.FieldProtein, occurrence.FieldSalt, occurrence.FieldPriceStudent, occurrence.FieldPriceStaff, occurrence.FieldPriceGuest:
			values[i] = new(sql.NullInt64)
		case occurrence.FieldDate, occurrence.FieldNotAvailableAfter:
			values[i] = new(sql.NullTime)
		case occurrence.FieldID:
			values[i] = new(uuid.UUID)
		case occurrence.ForeignKeys[0]: // dish
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case occurrence.ForeignKeys[1]: // location
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Occurrence fields.
func (o *Occurrence) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case occurrence.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				o.ID = *value
			}
		case occurrence.FieldDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field date", values[i])
			} else if value.Valid {
				o.Date = value.Time
			}
		case occurrence.FieldKj:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field kj", values[i])
			} else if value.Valid {
				o.Kj = new(int)
				*o.Kj = int(value.Int64)
			}
		case occurrence.FieldKcal:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field kcal", values[i])
			} else if value.Valid {
				o.Kcal = new(int)
				*o.Kcal = int(value.Int64)
			}
		case occurrence.FieldFat:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field fat", values[i])
			} else if value.Valid {
				o.Fat = new(int)
				*o.Fat = int(value.Int64)
			}
		case occurrence.FieldSaturatedFat:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field saturated_fat", values[i])
			} else if value.Valid {
				o.SaturatedFat = new(int)
				*o.SaturatedFat = int(value.Int64)
			}
		case occurrence.FieldCarbohydrates:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field carbohydrates", values[i])
			} else if value.Valid {
				o.Carbohydrates = new(int)
				*o.Carbohydrates = int(value.Int64)
			}
		case occurrence.FieldSugar:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sugar", values[i])
			} else if value.Valid {
				o.Sugar = new(int)
				*o.Sugar = int(value.Int64)
			}
		case occurrence.FieldFiber:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field fiber", values[i])
			} else if value.Valid {
				o.Fiber = new(int)
				*o.Fiber = int(value.Int64)
			}
		case occurrence.FieldProtein:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field protein", values[i])
			} else if value.Valid {
				o.Protein = new(int)
				*o.Protein = int(value.Int64)
			}
		case occurrence.FieldSalt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field salt", values[i])
			} else if value.Valid {
				o.Salt = new(int)
				*o.Salt = int(value.Int64)
			}
		case occurrence.FieldPriceStudent:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field price_student", values[i])
			} else if value.Valid {
				o.PriceStudent = new(int)
				*o.PriceStudent = int(value.Int64)
			}
		case occurrence.FieldPriceStaff:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field price_staff", values[i])
			} else if value.Valid {
				o.PriceStaff = new(int)
				*o.PriceStaff = int(value.Int64)
			}
		case occurrence.FieldPriceGuest:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field price_guest", values[i])
			} else if value.Valid {
				o.PriceGuest = new(int)
				*o.PriceGuest = int(value.Int64)
			}
		case occurrence.FieldNotAvailableAfter:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field notAvailableAfter", values[i])
			} else if value.Valid {
				o.NotAvailableAfter = new(time.Time)
				*o.NotAvailableAfter = value.Time
			}
		case occurrence.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field dish", values[i])
			} else if value.Valid {
				o.dish = new(uuid.UUID)
				*o.dish = *value.S.(*uuid.UUID)
			}
		case occurrence.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field location", values[i])
			} else if value.Valid {
				o.location = new(uuid.UUID)
				*o.location = *value.S.(*uuid.UUID)
			}
		default:
			o.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Occurrence.
// This includes values selected through modifiers, order, etc.
func (o *Occurrence) Value(name string) (ent.Value, error) {
	return o.selectValues.Get(name)
}

// QueryLocation queries the "location" edge of the Occurrence entity.
func (o *Occurrence) QueryLocation() *LocationQuery {
	return NewOccurrenceClient(o.config).QueryLocation(o)
}

// QueryDish queries the "dish" edge of the Occurrence entity.
func (o *Occurrence) QueryDish() *DishQuery {
	return NewOccurrenceClient(o.config).QueryDish(o)
}

// QueryTags queries the "tags" edge of the Occurrence entity.
func (o *Occurrence) QueryTags() *TagQuery {
	return NewOccurrenceClient(o.config).QueryTags(o)
}

// QuerySideDishes queries the "side_dishes" edge of the Occurrence entity.
func (o *Occurrence) QuerySideDishes() *DishQuery {
	return NewOccurrenceClient(o.config).QuerySideDishes(o)
}

// QueryReviews queries the "reviews" edge of the Occurrence entity.
func (o *Occurrence) QueryReviews() *ReviewQuery {
	return NewOccurrenceClient(o.config).QueryReviews(o)
}

// Update returns a builder for updating this Occurrence.
// Note that you need to call Occurrence.Unwrap() before calling this method if this Occurrence
// was returned from a transaction, and the transaction was committed or rolled back.
func (o *Occurrence) Update() *OccurrenceUpdateOne {
	return NewOccurrenceClient(o.config).UpdateOne(o)
}

// Unwrap unwraps the Occurrence entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (o *Occurrence) Unwrap() *Occurrence {
	_tx, ok := o.config.driver.(*txDriver)
	if !ok {
		panic("ent: Occurrence is not a transactional entity")
	}
	o.config.driver = _tx.drv
	return o
}

// String implements the fmt.Stringer.
func (o *Occurrence) String() string {
	var builder strings.Builder
	builder.WriteString("Occurrence(")
	builder.WriteString(fmt.Sprintf("id=%v, ", o.ID))
	builder.WriteString("date=")
	builder.WriteString(o.Date.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := o.Kj; v != nil {
		builder.WriteString("kj=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Kcal; v != nil {
		builder.WriteString("kcal=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Fat; v != nil {
		builder.WriteString("fat=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.SaturatedFat; v != nil {
		builder.WriteString("saturated_fat=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Carbohydrates; v != nil {
		builder.WriteString("carbohydrates=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Sugar; v != nil {
		builder.WriteString("sugar=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Fiber; v != nil {
		builder.WriteString("fiber=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Protein; v != nil {
		builder.WriteString("protein=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.Salt; v != nil {
		builder.WriteString("salt=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.PriceStudent; v != nil {
		builder.WriteString("price_student=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.PriceStaff; v != nil {
		builder.WriteString("price_staff=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.PriceGuest; v != nil {
		builder.WriteString("price_guest=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := o.NotAvailableAfter; v != nil {
		builder.WriteString("notAvailableAfter=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Occurrences is a parsable slice of Occurrence.
type Occurrences []*Occurrence
