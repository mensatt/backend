// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/mensatt/backend/internal/database/ent/dish"
	"github.com/mensatt/backend/internal/database/ent/dishalias"
	"github.com/mensatt/backend/internal/database/ent/image"
	"github.com/mensatt/backend/internal/database/ent/location"
	"github.com/mensatt/backend/internal/database/ent/occurrence"
	"github.com/mensatt/backend/internal/database/ent/predicate"
	"github.com/mensatt/backend/internal/database/ent/review"
	"github.com/mensatt/backend/internal/database/ent/tag"
	"github.com/mensatt/backend/internal/database/ent/user"
	"github.com/mensatt/backend/internal/database/schema"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDish       = "Dish"
	TypeDishAlias  = "DishAlias"
	TypeImage      = "Image"
	TypeLocation   = "Location"
	TypeOccurrence = "Occurrence"
	TypeReview     = "Review"
	TypeTag        = "Tag"
	TypeUser       = "User"
)

// DishMutation represents an operation that mutates the Dish nodes in the graph.
type DishMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	name_de                     *string
	name_en                     *string
	clearedFields               map[string]struct{}
	dish_occurrences            map[uuid.UUID]struct{}
	removeddish_occurrences     map[uuid.UUID]struct{}
	cleareddish_occurrences     bool
	aliases                     map[string]struct{}
	removedaliases              map[string]struct{}
	clearedaliases              bool
	side_dish_occurrence        map[uuid.UUID]struct{}
	removedside_dish_occurrence map[uuid.UUID]struct{}
	clearedside_dish_occurrence bool
	done                        bool
	oldValue                    func(context.Context) (*Dish, error)
	predicates                  []predicate.Dish
}

var _ ent.Mutation = (*DishMutation)(nil)

// dishOption allows management of the mutation configuration using functional options.
type dishOption func(*DishMutation)

// newDishMutation creates new mutation for the Dish entity.
func newDishMutation(c config, op Op, opts ...dishOption) *DishMutation {
	m := &DishMutation{
		config:        c,
		op:            op,
		typ:           TypeDish,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDishID sets the ID field of the mutation.
func withDishID(id uuid.UUID) dishOption {
	return func(m *DishMutation) {
		var (
			err   error
			once  sync.Once
			value *Dish
		)
		m.oldValue = func(ctx context.Context) (*Dish, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dish.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDish sets the old Dish of the mutation.
func withDish(node *Dish) dishOption {
	return func(m *DishMutation) {
		m.oldValue = func(context.Context) (*Dish, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DishMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DishMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dish entities.
func (m *DishMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DishMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DishMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dish.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameDe sets the "name_de" field.
func (m *DishMutation) SetNameDe(s string) {
	m.name_de = &s
}

// NameDe returns the value of the "name_de" field in the mutation.
func (m *DishMutation) NameDe() (r string, exists bool) {
	v := m.name_de
	if v == nil {
		return
	}
	return *v, true
}

// OldNameDe returns the old "name_de" field's value of the Dish entity.
// If the Dish object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DishMutation) OldNameDe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameDe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameDe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameDe: %w", err)
	}
	return oldValue.NameDe, nil
}

// ResetNameDe resets all changes to the "name_de" field.
func (m *DishMutation) ResetNameDe() {
	m.name_de = nil
}

// SetNameEn sets the "name_en" field.
func (m *DishMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *DishMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Dish entity.
// If the Dish object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DishMutation) OldNameEn(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ClearNameEn clears the value of the "name_en" field.
func (m *DishMutation) ClearNameEn() {
	m.name_en = nil
	m.clearedFields[dish.FieldNameEn] = struct{}{}
}

// NameEnCleared returns if the "name_en" field was cleared in this mutation.
func (m *DishMutation) NameEnCleared() bool {
	_, ok := m.clearedFields[dish.FieldNameEn]
	return ok
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *DishMutation) ResetNameEn() {
	m.name_en = nil
	delete(m.clearedFields, dish.FieldNameEn)
}

// AddDishOccurrenceIDs adds the "dish_occurrences" edge to the Occurrence entity by ids.
func (m *DishMutation) AddDishOccurrenceIDs(ids ...uuid.UUID) {
	if m.dish_occurrences == nil {
		m.dish_occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dish_occurrences[ids[i]] = struct{}{}
	}
}

// ClearDishOccurrences clears the "dish_occurrences" edge to the Occurrence entity.
func (m *DishMutation) ClearDishOccurrences() {
	m.cleareddish_occurrences = true
}

// DishOccurrencesCleared reports if the "dish_occurrences" edge to the Occurrence entity was cleared.
func (m *DishMutation) DishOccurrencesCleared() bool {
	return m.cleareddish_occurrences
}

// RemoveDishOccurrenceIDs removes the "dish_occurrences" edge to the Occurrence entity by IDs.
func (m *DishMutation) RemoveDishOccurrenceIDs(ids ...uuid.UUID) {
	if m.removeddish_occurrences == nil {
		m.removeddish_occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dish_occurrences, ids[i])
		m.removeddish_occurrences[ids[i]] = struct{}{}
	}
}

// RemovedDishOccurrences returns the removed IDs of the "dish_occurrences" edge to the Occurrence entity.
func (m *DishMutation) RemovedDishOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removeddish_occurrences {
		ids = append(ids, id)
	}
	return
}

// DishOccurrencesIDs returns the "dish_occurrences" edge IDs in the mutation.
func (m *DishMutation) DishOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.dish_occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetDishOccurrences resets all changes to the "dish_occurrences" edge.
func (m *DishMutation) ResetDishOccurrences() {
	m.dish_occurrences = nil
	m.cleareddish_occurrences = false
	m.removeddish_occurrences = nil
}

// AddAliasIDs adds the "aliases" edge to the DishAlias entity by ids.
func (m *DishMutation) AddAliasIDs(ids ...string) {
	if m.aliases == nil {
		m.aliases = make(map[string]struct{})
	}
	for i := range ids {
		m.aliases[ids[i]] = struct{}{}
	}
}

// ClearAliases clears the "aliases" edge to the DishAlias entity.
func (m *DishMutation) ClearAliases() {
	m.clearedaliases = true
}

// AliasesCleared reports if the "aliases" edge to the DishAlias entity was cleared.
func (m *DishMutation) AliasesCleared() bool {
	return m.clearedaliases
}

// RemoveAliasIDs removes the "aliases" edge to the DishAlias entity by IDs.
func (m *DishMutation) RemoveAliasIDs(ids ...string) {
	if m.removedaliases == nil {
		m.removedaliases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.aliases, ids[i])
		m.removedaliases[ids[i]] = struct{}{}
	}
}

// RemovedAliases returns the removed IDs of the "aliases" edge to the DishAlias entity.
func (m *DishMutation) RemovedAliasesIDs() (ids []string) {
	for id := range m.removedaliases {
		ids = append(ids, id)
	}
	return
}

// AliasesIDs returns the "aliases" edge IDs in the mutation.
func (m *DishMutation) AliasesIDs() (ids []string) {
	for id := range m.aliases {
		ids = append(ids, id)
	}
	return
}

// ResetAliases resets all changes to the "aliases" edge.
func (m *DishMutation) ResetAliases() {
	m.aliases = nil
	m.clearedaliases = false
	m.removedaliases = nil
}

// AddSideDishOccurrenceIDs adds the "side_dish_occurrence" edge to the Occurrence entity by ids.
func (m *DishMutation) AddSideDishOccurrenceIDs(ids ...uuid.UUID) {
	if m.side_dish_occurrence == nil {
		m.side_dish_occurrence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.side_dish_occurrence[ids[i]] = struct{}{}
	}
}

// ClearSideDishOccurrence clears the "side_dish_occurrence" edge to the Occurrence entity.
func (m *DishMutation) ClearSideDishOccurrence() {
	m.clearedside_dish_occurrence = true
}

// SideDishOccurrenceCleared reports if the "side_dish_occurrence" edge to the Occurrence entity was cleared.
func (m *DishMutation) SideDishOccurrenceCleared() bool {
	return m.clearedside_dish_occurrence
}

// RemoveSideDishOccurrenceIDs removes the "side_dish_occurrence" edge to the Occurrence entity by IDs.
func (m *DishMutation) RemoveSideDishOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedside_dish_occurrence == nil {
		m.removedside_dish_occurrence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.side_dish_occurrence, ids[i])
		m.removedside_dish_occurrence[ids[i]] = struct{}{}
	}
}

// RemovedSideDishOccurrence returns the removed IDs of the "side_dish_occurrence" edge to the Occurrence entity.
func (m *DishMutation) RemovedSideDishOccurrenceIDs() (ids []uuid.UUID) {
	for id := range m.removedside_dish_occurrence {
		ids = append(ids, id)
	}
	return
}

// SideDishOccurrenceIDs returns the "side_dish_occurrence" edge IDs in the mutation.
func (m *DishMutation) SideDishOccurrenceIDs() (ids []uuid.UUID) {
	for id := range m.side_dish_occurrence {
		ids = append(ids, id)
	}
	return
}

// ResetSideDishOccurrence resets all changes to the "side_dish_occurrence" edge.
func (m *DishMutation) ResetSideDishOccurrence() {
	m.side_dish_occurrence = nil
	m.clearedside_dish_occurrence = false
	m.removedside_dish_occurrence = nil
}

// Where appends a list predicates to the DishMutation builder.
func (m *DishMutation) Where(ps ...predicate.Dish) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DishMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DishMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dish, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DishMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DishMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dish).
func (m *DishMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DishMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name_de != nil {
		fields = append(fields, dish.FieldNameDe)
	}
	if m.name_en != nil {
		fields = append(fields, dish.FieldNameEn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DishMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dish.FieldNameDe:
		return m.NameDe()
	case dish.FieldNameEn:
		return m.NameEn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DishMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dish.FieldNameDe:
		return m.OldNameDe(ctx)
	case dish.FieldNameEn:
		return m.OldNameEn(ctx)
	}
	return nil, fmt.Errorf("unknown Dish field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DishMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dish.FieldNameDe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameDe(v)
		return nil
	case dish.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	}
	return fmt.Errorf("unknown Dish field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DishMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DishMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DishMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dish numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DishMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dish.FieldNameEn) {
		fields = append(fields, dish.FieldNameEn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DishMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DishMutation) ClearField(name string) error {
	switch name {
	case dish.FieldNameEn:
		m.ClearNameEn()
		return nil
	}
	return fmt.Errorf("unknown Dish nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DishMutation) ResetField(name string) error {
	switch name {
	case dish.FieldNameDe:
		m.ResetNameDe()
		return nil
	case dish.FieldNameEn:
		m.ResetNameEn()
		return nil
	}
	return fmt.Errorf("unknown Dish field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DishMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dish_occurrences != nil {
		edges = append(edges, dish.EdgeDishOccurrences)
	}
	if m.aliases != nil {
		edges = append(edges, dish.EdgeAliases)
	}
	if m.side_dish_occurrence != nil {
		edges = append(edges, dish.EdgeSideDishOccurrence)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DishMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dish.EdgeDishOccurrences:
		ids := make([]ent.Value, 0, len(m.dish_occurrences))
		for id := range m.dish_occurrences {
			ids = append(ids, id)
		}
		return ids
	case dish.EdgeAliases:
		ids := make([]ent.Value, 0, len(m.aliases))
		for id := range m.aliases {
			ids = append(ids, id)
		}
		return ids
	case dish.EdgeSideDishOccurrence:
		ids := make([]ent.Value, 0, len(m.side_dish_occurrence))
		for id := range m.side_dish_occurrence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DishMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddish_occurrences != nil {
		edges = append(edges, dish.EdgeDishOccurrences)
	}
	if m.removedaliases != nil {
		edges = append(edges, dish.EdgeAliases)
	}
	if m.removedside_dish_occurrence != nil {
		edges = append(edges, dish.EdgeSideDishOccurrence)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DishMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dish.EdgeDishOccurrences:
		ids := make([]ent.Value, 0, len(m.removeddish_occurrences))
		for id := range m.removeddish_occurrences {
			ids = append(ids, id)
		}
		return ids
	case dish.EdgeAliases:
		ids := make([]ent.Value, 0, len(m.removedaliases))
		for id := range m.removedaliases {
			ids = append(ids, id)
		}
		return ids
	case dish.EdgeSideDishOccurrence:
		ids := make([]ent.Value, 0, len(m.removedside_dish_occurrence))
		for id := range m.removedside_dish_occurrence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DishMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddish_occurrences {
		edges = append(edges, dish.EdgeDishOccurrences)
	}
	if m.clearedaliases {
		edges = append(edges, dish.EdgeAliases)
	}
	if m.clearedside_dish_occurrence {
		edges = append(edges, dish.EdgeSideDishOccurrence)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DishMutation) EdgeCleared(name string) bool {
	switch name {
	case dish.EdgeDishOccurrences:
		return m.cleareddish_occurrences
	case dish.EdgeAliases:
		return m.clearedaliases
	case dish.EdgeSideDishOccurrence:
		return m.clearedside_dish_occurrence
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DishMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dish unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DishMutation) ResetEdge(name string) error {
	switch name {
	case dish.EdgeDishOccurrences:
		m.ResetDishOccurrences()
		return nil
	case dish.EdgeAliases:
		m.ResetAliases()
		return nil
	case dish.EdgeSideDishOccurrence:
		m.ResetSideDishOccurrence()
		return nil
	}
	return fmt.Errorf("unknown Dish edge %s", name)
}

// DishAliasMutation represents an operation that mutates the DishAlias nodes in the graph.
type DishAliasMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	normalized_alias_name *string
	clearedFields         map[string]struct{}
	dish                  *uuid.UUID
	cleareddish           bool
	done                  bool
	oldValue              func(context.Context) (*DishAlias, error)
	predicates            []predicate.DishAlias
}

var _ ent.Mutation = (*DishAliasMutation)(nil)

// dishaliasOption allows management of the mutation configuration using functional options.
type dishaliasOption func(*DishAliasMutation)

// newDishAliasMutation creates new mutation for the DishAlias entity.
func newDishAliasMutation(c config, op Op, opts ...dishaliasOption) *DishAliasMutation {
	m := &DishAliasMutation{
		config:        c,
		op:            op,
		typ:           TypeDishAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDishAliasID sets the ID field of the mutation.
func withDishAliasID(id string) dishaliasOption {
	return func(m *DishAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *DishAlias
		)
		m.oldValue = func(ctx context.Context) (*DishAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DishAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDishAlias sets the old DishAlias of the mutation.
func withDishAlias(node *DishAlias) dishaliasOption {
	return func(m *DishAliasMutation) {
		m.oldValue = func(context.Context) (*DishAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DishAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DishAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DishAlias entities.
func (m *DishAliasMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DishAliasMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DishAliasMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DishAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNormalizedAliasName sets the "normalized_alias_name" field.
func (m *DishAliasMutation) SetNormalizedAliasName(s string) {
	m.normalized_alias_name = &s
}

// NormalizedAliasName returns the value of the "normalized_alias_name" field in the mutation.
func (m *DishAliasMutation) NormalizedAliasName() (r string, exists bool) {
	v := m.normalized_alias_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalizedAliasName returns the old "normalized_alias_name" field's value of the DishAlias entity.
// If the DishAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DishAliasMutation) OldNormalizedAliasName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalizedAliasName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalizedAliasName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalizedAliasName: %w", err)
	}
	return oldValue.NormalizedAliasName, nil
}

// ResetNormalizedAliasName resets all changes to the "normalized_alias_name" field.
func (m *DishAliasMutation) ResetNormalizedAliasName() {
	m.normalized_alias_name = nil
}

// SetDishID sets the "dish" edge to the Dish entity by id.
func (m *DishAliasMutation) SetDishID(id uuid.UUID) {
	m.dish = &id
}

// ClearDish clears the "dish" edge to the Dish entity.
func (m *DishAliasMutation) ClearDish() {
	m.cleareddish = true
}

// DishCleared reports if the "dish" edge to the Dish entity was cleared.
func (m *DishAliasMutation) DishCleared() bool {
	return m.cleareddish
}

// DishID returns the "dish" edge ID in the mutation.
func (m *DishAliasMutation) DishID() (id uuid.UUID, exists bool) {
	if m.dish != nil {
		return *m.dish, true
	}
	return
}

// DishIDs returns the "dish" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DishID instead. It exists only for internal usage by the builders.
func (m *DishAliasMutation) DishIDs() (ids []uuid.UUID) {
	if id := m.dish; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDish resets all changes to the "dish" edge.
func (m *DishAliasMutation) ResetDish() {
	m.dish = nil
	m.cleareddish = false
}

// Where appends a list predicates to the DishAliasMutation builder.
func (m *DishAliasMutation) Where(ps ...predicate.DishAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DishAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DishAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DishAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DishAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DishAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DishAlias).
func (m *DishAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DishAliasMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.normalized_alias_name != nil {
		fields = append(fields, dishalias.FieldNormalizedAliasName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DishAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dishalias.FieldNormalizedAliasName:
		return m.NormalizedAliasName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DishAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dishalias.FieldNormalizedAliasName:
		return m.OldNormalizedAliasName(ctx)
	}
	return nil, fmt.Errorf("unknown DishAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DishAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dishalias.FieldNormalizedAliasName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalizedAliasName(v)
		return nil
	}
	return fmt.Errorf("unknown DishAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DishAliasMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DishAliasMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DishAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DishAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DishAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DishAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DishAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DishAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DishAliasMutation) ResetField(name string) error {
	switch name {
	case dishalias.FieldNormalizedAliasName:
		m.ResetNormalizedAliasName()
		return nil
	}
	return fmt.Errorf("unknown DishAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DishAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dish != nil {
		edges = append(edges, dishalias.EdgeDish)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DishAliasMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dishalias.EdgeDish:
		if id := m.dish; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DishAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DishAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DishAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddish {
		edges = append(edges, dishalias.EdgeDish)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DishAliasMutation) EdgeCleared(name string) bool {
	switch name {
	case dishalias.EdgeDish:
		return m.cleareddish
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DishAliasMutation) ClearEdge(name string) error {
	switch name {
	case dishalias.EdgeDish:
		m.ClearDish()
		return nil
	}
	return fmt.Errorf("unknown DishAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DishAliasMutation) ResetEdge(name string) error {
	switch name {
	case dishalias.EdgeDish:
		m.ResetDish()
		return nil
	}
	return fmt.Errorf("unknown DishAlias edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	image_hash    *string
	clearedFields map[string]struct{}
	review        *uuid.UUID
	clearedreview bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImageHash sets the "image_hash" field.
func (m *ImageMutation) SetImageHash(s string) {
	m.image_hash = &s
}

// ImageHash returns the value of the "image_hash" field in the mutation.
func (m *ImageMutation) ImageHash() (r string, exists bool) {
	v := m.image_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldImageHash returns the old "image_hash" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldImageHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageHash: %w", err)
	}
	return oldValue.ImageHash, nil
}

// ResetImageHash resets all changes to the "image_hash" field.
func (m *ImageMutation) ResetImageHash() {
	m.image_hash = nil
}

// SetReviewID sets the "review" edge to the Review entity by id.
func (m *ImageMutation) SetReviewID(id uuid.UUID) {
	m.review = &id
}

// ClearReview clears the "review" edge to the Review entity.
func (m *ImageMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *ImageMutation) ReviewCleared() bool {
	return m.clearedreview
}

// ReviewID returns the "review" edge ID in the mutation.
func (m *ImageMutation) ReviewID() (id uuid.UUID, exists bool) {
	if m.review != nil {
		return *m.review, true
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) ReviewIDs() (ids []uuid.UUID) {
	if id := m.review; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *ImageMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.image_hash != nil {
		fields = append(fields, image.FieldImageHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldImageHash:
		return m.ImageHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldImageHash:
		return m.OldImageHash(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldImageHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageHash(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldImageHash:
		m.ResetImageHash()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.review != nil {
		edges = append(edges, image.EdgeReview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeReview:
		if id := m.review; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreview {
		edges = append(edges, image.EdgeReview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeReview:
		return m.clearedreview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeReview:
		m.ClearReview()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeReview:
		m.ResetReview()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	external_id        *int
	addexternal_id     *int
	name               *string
	visible            *bool
	clearedFields      map[string]struct{}
	occurrences        map[uuid.UUID]struct{}
	removedoccurrences map[uuid.UUID]struct{}
	clearedoccurrences bool
	done               bool
	oldValue           func(context.Context) (*Location, error)
	predicates         []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uuid.UUID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExternalID sets the "external_id" field.
func (m *LocationMutation) SetExternalID(i int) {
	m.external_id = &i
	m.addexternal_id = nil
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *LocationMutation) ExternalID() (r int, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldExternalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// AddExternalID adds i to the "external_id" field.
func (m *LocationMutation) AddExternalID(i int) {
	if m.addexternal_id != nil {
		*m.addexternal_id += i
	} else {
		m.addexternal_id = &i
	}
}

// AddedExternalID returns the value that was added to the "external_id" field in this mutation.
func (m *LocationMutation) AddedExternalID() (r int, exists bool) {
	v := m.addexternal_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *LocationMutation) ResetExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetVisible sets the "visible" field.
func (m *LocationMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *LocationMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *LocationMutation) ResetVisible() {
	m.visible = nil
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *LocationMutation) AddOccurrenceIDs(ids ...uuid.UUID) {
	if m.occurrences == nil {
		m.occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *LocationMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *LocationMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *LocationMutation) RemoveOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *LocationMutation) RemovedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *LocationMutation) OccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *LocationMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.external_id != nil {
		fields = append(fields, location.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.visible != nil {
		fields = append(fields, location.FieldVisible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldExternalID:
		return m.ExternalID()
	case location.FieldName:
		return m.Name()
	case location.FieldVisible:
		return m.Visible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldExternalID:
		return m.OldExternalID(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldVisible:
		return m.OldVisible(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addexternal_id != nil {
		fields = append(fields, location.FieldExternalID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldExternalID:
		return m.AddedExternalID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldExternalID:
		m.ResetExternalID()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldVisible:
		m.ResetVisible()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.occurrences != nil {
		edges = append(edges, location.EdgeOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedoccurrences != nil {
		edges = append(edges, location.EdgeOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoccurrences {
		edges = append(edges, location.EdgeOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeOccurrences:
		return m.clearedoccurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// OccurrenceMutation represents an operation that mutates the Occurrence nodes in the graph.
type OccurrenceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	date                *time.Time
	kj                  *int
	addkj               *int
	kcal                *int
	addkcal             *int
	fat                 *int
	addfat              *int
	saturated_fat       *int
	addsaturated_fat    *int
	carbohydrates       *int
	addcarbohydrates    *int
	sugar               *int
	addsugar            *int
	fiber               *int
	addfiber            *int
	protein             *int
	addprotein          *int
	salt                *int
	addsalt             *int
	price_student       *int
	addprice_student    *int
	price_staff         *int
	addprice_staff      *int
	price_guest         *int
	addprice_guest      *int
	not_available_after *time.Time
	clearedFields       map[string]struct{}
	location            *uuid.UUID
	clearedlocation     bool
	dish                *uuid.UUID
	cleareddish         bool
	tags                map[string]struct{}
	removedtags         map[string]struct{}
	clearedtags         bool
	side_dishes         map[uuid.UUID]struct{}
	removedside_dishes  map[uuid.UUID]struct{}
	clearedside_dishes  bool
	reviews             map[uuid.UUID]struct{}
	removedreviews      map[uuid.UUID]struct{}
	clearedreviews      bool
	done                bool
	oldValue            func(context.Context) (*Occurrence, error)
	predicates          []predicate.Occurrence
}

var _ ent.Mutation = (*OccurrenceMutation)(nil)

// occurrenceOption allows management of the mutation configuration using functional options.
type occurrenceOption func(*OccurrenceMutation)

// newOccurrenceMutation creates new mutation for the Occurrence entity.
func newOccurrenceMutation(c config, op Op, opts ...occurrenceOption) *OccurrenceMutation {
	m := &OccurrenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceID sets the ID field of the mutation.
func withOccurrenceID(id uuid.UUID) occurrenceOption {
	return func(m *OccurrenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurrence
		)
		m.oldValue = func(ctx context.Context) (*Occurrence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurrence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrence sets the old Occurrence of the mutation.
func withOccurrence(node *Occurrence) occurrenceOption {
	return func(m *OccurrenceMutation) {
		m.oldValue = func(context.Context) (*Occurrence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Occurrence entities.
func (m *OccurrenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occurrence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *OccurrenceMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *OccurrenceMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *OccurrenceMutation) ResetDate() {
	m.date = nil
}

// SetKj sets the "kj" field.
func (m *OccurrenceMutation) SetKj(i int) {
	m.kj = &i
	m.addkj = nil
}

// Kj returns the value of the "kj" field in the mutation.
func (m *OccurrenceMutation) Kj() (r int, exists bool) {
	v := m.kj
	if v == nil {
		return
	}
	return *v, true
}

// OldKj returns the old "kj" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldKj(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKj: %w", err)
	}
	return oldValue.Kj, nil
}

// AddKj adds i to the "kj" field.
func (m *OccurrenceMutation) AddKj(i int) {
	if m.addkj != nil {
		*m.addkj += i
	} else {
		m.addkj = &i
	}
}

// AddedKj returns the value that was added to the "kj" field in this mutation.
func (m *OccurrenceMutation) AddedKj() (r int, exists bool) {
	v := m.addkj
	if v == nil {
		return
	}
	return *v, true
}

// ClearKj clears the value of the "kj" field.
func (m *OccurrenceMutation) ClearKj() {
	m.kj = nil
	m.addkj = nil
	m.clearedFields[occurrence.FieldKj] = struct{}{}
}

// KjCleared returns if the "kj" field was cleared in this mutation.
func (m *OccurrenceMutation) KjCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldKj]
	return ok
}

// ResetKj resets all changes to the "kj" field.
func (m *OccurrenceMutation) ResetKj() {
	m.kj = nil
	m.addkj = nil
	delete(m.clearedFields, occurrence.FieldKj)
}

// SetKcal sets the "kcal" field.
func (m *OccurrenceMutation) SetKcal(i int) {
	m.kcal = &i
	m.addkcal = nil
}

// Kcal returns the value of the "kcal" field in the mutation.
func (m *OccurrenceMutation) Kcal() (r int, exists bool) {
	v := m.kcal
	if v == nil {
		return
	}
	return *v, true
}

// OldKcal returns the old "kcal" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldKcal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKcal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKcal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKcal: %w", err)
	}
	return oldValue.Kcal, nil
}

// AddKcal adds i to the "kcal" field.
func (m *OccurrenceMutation) AddKcal(i int) {
	if m.addkcal != nil {
		*m.addkcal += i
	} else {
		m.addkcal = &i
	}
}

// AddedKcal returns the value that was added to the "kcal" field in this mutation.
func (m *OccurrenceMutation) AddedKcal() (r int, exists bool) {
	v := m.addkcal
	if v == nil {
		return
	}
	return *v, true
}

// ClearKcal clears the value of the "kcal" field.
func (m *OccurrenceMutation) ClearKcal() {
	m.kcal = nil
	m.addkcal = nil
	m.clearedFields[occurrence.FieldKcal] = struct{}{}
}

// KcalCleared returns if the "kcal" field was cleared in this mutation.
func (m *OccurrenceMutation) KcalCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldKcal]
	return ok
}

// ResetKcal resets all changes to the "kcal" field.
func (m *OccurrenceMutation) ResetKcal() {
	m.kcal = nil
	m.addkcal = nil
	delete(m.clearedFields, occurrence.FieldKcal)
}

// SetFat sets the "fat" field.
func (m *OccurrenceMutation) SetFat(i int) {
	m.fat = &i
	m.addfat = nil
}

// Fat returns the value of the "fat" field in the mutation.
func (m *OccurrenceMutation) Fat() (r int, exists bool) {
	v := m.fat
	if v == nil {
		return
	}
	return *v, true
}

// OldFat returns the old "fat" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldFat(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFat: %w", err)
	}
	return oldValue.Fat, nil
}

// AddFat adds i to the "fat" field.
func (m *OccurrenceMutation) AddFat(i int) {
	if m.addfat != nil {
		*m.addfat += i
	} else {
		m.addfat = &i
	}
}

// AddedFat returns the value that was added to the "fat" field in this mutation.
func (m *OccurrenceMutation) AddedFat() (r int, exists bool) {
	v := m.addfat
	if v == nil {
		return
	}
	return *v, true
}

// ClearFat clears the value of the "fat" field.
func (m *OccurrenceMutation) ClearFat() {
	m.fat = nil
	m.addfat = nil
	m.clearedFields[occurrence.FieldFat] = struct{}{}
}

// FatCleared returns if the "fat" field was cleared in this mutation.
func (m *OccurrenceMutation) FatCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldFat]
	return ok
}

// ResetFat resets all changes to the "fat" field.
func (m *OccurrenceMutation) ResetFat() {
	m.fat = nil
	m.addfat = nil
	delete(m.clearedFields, occurrence.FieldFat)
}

// SetSaturatedFat sets the "saturated_fat" field.
func (m *OccurrenceMutation) SetSaturatedFat(i int) {
	m.saturated_fat = &i
	m.addsaturated_fat = nil
}

// SaturatedFat returns the value of the "saturated_fat" field in the mutation.
func (m *OccurrenceMutation) SaturatedFat() (r int, exists bool) {
	v := m.saturated_fat
	if v == nil {
		return
	}
	return *v, true
}

// OldSaturatedFat returns the old "saturated_fat" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSaturatedFat(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaturatedFat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaturatedFat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaturatedFat: %w", err)
	}
	return oldValue.SaturatedFat, nil
}

// AddSaturatedFat adds i to the "saturated_fat" field.
func (m *OccurrenceMutation) AddSaturatedFat(i int) {
	if m.addsaturated_fat != nil {
		*m.addsaturated_fat += i
	} else {
		m.addsaturated_fat = &i
	}
}

// AddedSaturatedFat returns the value that was added to the "saturated_fat" field in this mutation.
func (m *OccurrenceMutation) AddedSaturatedFat() (r int, exists bool) {
	v := m.addsaturated_fat
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaturatedFat clears the value of the "saturated_fat" field.
func (m *OccurrenceMutation) ClearSaturatedFat() {
	m.saturated_fat = nil
	m.addsaturated_fat = nil
	m.clearedFields[occurrence.FieldSaturatedFat] = struct{}{}
}

// SaturatedFatCleared returns if the "saturated_fat" field was cleared in this mutation.
func (m *OccurrenceMutation) SaturatedFatCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSaturatedFat]
	return ok
}

// ResetSaturatedFat resets all changes to the "saturated_fat" field.
func (m *OccurrenceMutation) ResetSaturatedFat() {
	m.saturated_fat = nil
	m.addsaturated_fat = nil
	delete(m.clearedFields, occurrence.FieldSaturatedFat)
}

// SetCarbohydrates sets the "carbohydrates" field.
func (m *OccurrenceMutation) SetCarbohydrates(i int) {
	m.carbohydrates = &i
	m.addcarbohydrates = nil
}

// Carbohydrates returns the value of the "carbohydrates" field in the mutation.
func (m *OccurrenceMutation) Carbohydrates() (r int, exists bool) {
	v := m.carbohydrates
	if v == nil {
		return
	}
	return *v, true
}

// OldCarbohydrates returns the old "carbohydrates" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldCarbohydrates(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarbohydrates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarbohydrates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarbohydrates: %w", err)
	}
	return oldValue.Carbohydrates, nil
}

// AddCarbohydrates adds i to the "carbohydrates" field.
func (m *OccurrenceMutation) AddCarbohydrates(i int) {
	if m.addcarbohydrates != nil {
		*m.addcarbohydrates += i
	} else {
		m.addcarbohydrates = &i
	}
}

// AddedCarbohydrates returns the value that was added to the "carbohydrates" field in this mutation.
func (m *OccurrenceMutation) AddedCarbohydrates() (r int, exists bool) {
	v := m.addcarbohydrates
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarbohydrates clears the value of the "carbohydrates" field.
func (m *OccurrenceMutation) ClearCarbohydrates() {
	m.carbohydrates = nil
	m.addcarbohydrates = nil
	m.clearedFields[occurrence.FieldCarbohydrates] = struct{}{}
}

// CarbohydratesCleared returns if the "carbohydrates" field was cleared in this mutation.
func (m *OccurrenceMutation) CarbohydratesCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldCarbohydrates]
	return ok
}

// ResetCarbohydrates resets all changes to the "carbohydrates" field.
func (m *OccurrenceMutation) ResetCarbohydrates() {
	m.carbohydrates = nil
	m.addcarbohydrates = nil
	delete(m.clearedFields, occurrence.FieldCarbohydrates)
}

// SetSugar sets the "sugar" field.
func (m *OccurrenceMutation) SetSugar(i int) {
	m.sugar = &i
	m.addsugar = nil
}

// Sugar returns the value of the "sugar" field in the mutation.
func (m *OccurrenceMutation) Sugar() (r int, exists bool) {
	v := m.sugar
	if v == nil {
		return
	}
	return *v, true
}

// OldSugar returns the old "sugar" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSugar(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSugar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSugar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSugar: %w", err)
	}
	return oldValue.Sugar, nil
}

// AddSugar adds i to the "sugar" field.
func (m *OccurrenceMutation) AddSugar(i int) {
	if m.addsugar != nil {
		*m.addsugar += i
	} else {
		m.addsugar = &i
	}
}

// AddedSugar returns the value that was added to the "sugar" field in this mutation.
func (m *OccurrenceMutation) AddedSugar() (r int, exists bool) {
	v := m.addsugar
	if v == nil {
		return
	}
	return *v, true
}

// ClearSugar clears the value of the "sugar" field.
func (m *OccurrenceMutation) ClearSugar() {
	m.sugar = nil
	m.addsugar = nil
	m.clearedFields[occurrence.FieldSugar] = struct{}{}
}

// SugarCleared returns if the "sugar" field was cleared in this mutation.
func (m *OccurrenceMutation) SugarCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSugar]
	return ok
}

// ResetSugar resets all changes to the "sugar" field.
func (m *OccurrenceMutation) ResetSugar() {
	m.sugar = nil
	m.addsugar = nil
	delete(m.clearedFields, occurrence.FieldSugar)
}

// SetFiber sets the "fiber" field.
func (m *OccurrenceMutation) SetFiber(i int) {
	m.fiber = &i
	m.addfiber = nil
}

// Fiber returns the value of the "fiber" field in the mutation.
func (m *OccurrenceMutation) Fiber() (r int, exists bool) {
	v := m.fiber
	if v == nil {
		return
	}
	return *v, true
}

// OldFiber returns the old "fiber" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldFiber(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiber: %w", err)
	}
	return oldValue.Fiber, nil
}

// AddFiber adds i to the "fiber" field.
func (m *OccurrenceMutation) AddFiber(i int) {
	if m.addfiber != nil {
		*m.addfiber += i
	} else {
		m.addfiber = &i
	}
}

// AddedFiber returns the value that was added to the "fiber" field in this mutation.
func (m *OccurrenceMutation) AddedFiber() (r int, exists bool) {
	v := m.addfiber
	if v == nil {
		return
	}
	return *v, true
}

// ClearFiber clears the value of the "fiber" field.
func (m *OccurrenceMutation) ClearFiber() {
	m.fiber = nil
	m.addfiber = nil
	m.clearedFields[occurrence.FieldFiber] = struct{}{}
}

// FiberCleared returns if the "fiber" field was cleared in this mutation.
func (m *OccurrenceMutation) FiberCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldFiber]
	return ok
}

// ResetFiber resets all changes to the "fiber" field.
func (m *OccurrenceMutation) ResetFiber() {
	m.fiber = nil
	m.addfiber = nil
	delete(m.clearedFields, occurrence.FieldFiber)
}

// SetProtein sets the "protein" field.
func (m *OccurrenceMutation) SetProtein(i int) {
	m.protein = &i
	m.addprotein = nil
}

// Protein returns the value of the "protein" field in the mutation.
func (m *OccurrenceMutation) Protein() (r int, exists bool) {
	v := m.protein
	if v == nil {
		return
	}
	return *v, true
}

// OldProtein returns the old "protein" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldProtein(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtein is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtein requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtein: %w", err)
	}
	return oldValue.Protein, nil
}

// AddProtein adds i to the "protein" field.
func (m *OccurrenceMutation) AddProtein(i int) {
	if m.addprotein != nil {
		*m.addprotein += i
	} else {
		m.addprotein = &i
	}
}

// AddedProtein returns the value that was added to the "protein" field in this mutation.
func (m *OccurrenceMutation) AddedProtein() (r int, exists bool) {
	v := m.addprotein
	if v == nil {
		return
	}
	return *v, true
}

// ClearProtein clears the value of the "protein" field.
func (m *OccurrenceMutation) ClearProtein() {
	m.protein = nil
	m.addprotein = nil
	m.clearedFields[occurrence.FieldProtein] = struct{}{}
}

// ProteinCleared returns if the "protein" field was cleared in this mutation.
func (m *OccurrenceMutation) ProteinCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldProtein]
	return ok
}

// ResetProtein resets all changes to the "protein" field.
func (m *OccurrenceMutation) ResetProtein() {
	m.protein = nil
	m.addprotein = nil
	delete(m.clearedFields, occurrence.FieldProtein)
}

// SetSalt sets the "salt" field.
func (m *OccurrenceMutation) SetSalt(i int) {
	m.salt = &i
	m.addsalt = nil
}

// Salt returns the value of the "salt" field in the mutation.
func (m *OccurrenceMutation) Salt() (r int, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSalt(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// AddSalt adds i to the "salt" field.
func (m *OccurrenceMutation) AddSalt(i int) {
	if m.addsalt != nil {
		*m.addsalt += i
	} else {
		m.addsalt = &i
	}
}

// AddedSalt returns the value that was added to the "salt" field in this mutation.
func (m *OccurrenceMutation) AddedSalt() (r int, exists bool) {
	v := m.addsalt
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalt clears the value of the "salt" field.
func (m *OccurrenceMutation) ClearSalt() {
	m.salt = nil
	m.addsalt = nil
	m.clearedFields[occurrence.FieldSalt] = struct{}{}
}

// SaltCleared returns if the "salt" field was cleared in this mutation.
func (m *OccurrenceMutation) SaltCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSalt]
	return ok
}

// ResetSalt resets all changes to the "salt" field.
func (m *OccurrenceMutation) ResetSalt() {
	m.salt = nil
	m.addsalt = nil
	delete(m.clearedFields, occurrence.FieldSalt)
}

// SetPriceStudent sets the "price_student" field.
func (m *OccurrenceMutation) SetPriceStudent(i int) {
	m.price_student = &i
	m.addprice_student = nil
}

// PriceStudent returns the value of the "price_student" field in the mutation.
func (m *OccurrenceMutation) PriceStudent() (r int, exists bool) {
	v := m.price_student
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceStudent returns the old "price_student" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPriceStudent(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceStudent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceStudent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceStudent: %w", err)
	}
	return oldValue.PriceStudent, nil
}

// AddPriceStudent adds i to the "price_student" field.
func (m *OccurrenceMutation) AddPriceStudent(i int) {
	if m.addprice_student != nil {
		*m.addprice_student += i
	} else {
		m.addprice_student = &i
	}
}

// AddedPriceStudent returns the value that was added to the "price_student" field in this mutation.
func (m *OccurrenceMutation) AddedPriceStudent() (r int, exists bool) {
	v := m.addprice_student
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriceStudent clears the value of the "price_student" field.
func (m *OccurrenceMutation) ClearPriceStudent() {
	m.price_student = nil
	m.addprice_student = nil
	m.clearedFields[occurrence.FieldPriceStudent] = struct{}{}
}

// PriceStudentCleared returns if the "price_student" field was cleared in this mutation.
func (m *OccurrenceMutation) PriceStudentCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPriceStudent]
	return ok
}

// ResetPriceStudent resets all changes to the "price_student" field.
func (m *OccurrenceMutation) ResetPriceStudent() {
	m.price_student = nil
	m.addprice_student = nil
	delete(m.clearedFields, occurrence.FieldPriceStudent)
}

// SetPriceStaff sets the "price_staff" field.
func (m *OccurrenceMutation) SetPriceStaff(i int) {
	m.price_staff = &i
	m.addprice_staff = nil
}

// PriceStaff returns the value of the "price_staff" field in the mutation.
func (m *OccurrenceMutation) PriceStaff() (r int, exists bool) {
	v := m.price_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceStaff returns the old "price_staff" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPriceStaff(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceStaff: %w", err)
	}
	return oldValue.PriceStaff, nil
}

// AddPriceStaff adds i to the "price_staff" field.
func (m *OccurrenceMutation) AddPriceStaff(i int) {
	if m.addprice_staff != nil {
		*m.addprice_staff += i
	} else {
		m.addprice_staff = &i
	}
}

// AddedPriceStaff returns the value that was added to the "price_staff" field in this mutation.
func (m *OccurrenceMutation) AddedPriceStaff() (r int, exists bool) {
	v := m.addprice_staff
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriceStaff clears the value of the "price_staff" field.
func (m *OccurrenceMutation) ClearPriceStaff() {
	m.price_staff = nil
	m.addprice_staff = nil
	m.clearedFields[occurrence.FieldPriceStaff] = struct{}{}
}

// PriceStaffCleared returns if the "price_staff" field was cleared in this mutation.
func (m *OccurrenceMutation) PriceStaffCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPriceStaff]
	return ok
}

// ResetPriceStaff resets all changes to the "price_staff" field.
func (m *OccurrenceMutation) ResetPriceStaff() {
	m.price_staff = nil
	m.addprice_staff = nil
	delete(m.clearedFields, occurrence.FieldPriceStaff)
}

// SetPriceGuest sets the "price_guest" field.
func (m *OccurrenceMutation) SetPriceGuest(i int) {
	m.price_guest = &i
	m.addprice_guest = nil
}

// PriceGuest returns the value of the "price_guest" field in the mutation.
func (m *OccurrenceMutation) PriceGuest() (r int, exists bool) {
	v := m.price_guest
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceGuest returns the old "price_guest" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPriceGuest(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceGuest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceGuest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceGuest: %w", err)
	}
	return oldValue.PriceGuest, nil
}

// AddPriceGuest adds i to the "price_guest" field.
func (m *OccurrenceMutation) AddPriceGuest(i int) {
	if m.addprice_guest != nil {
		*m.addprice_guest += i
	} else {
		m.addprice_guest = &i
	}
}

// AddedPriceGuest returns the value that was added to the "price_guest" field in this mutation.
func (m *OccurrenceMutation) AddedPriceGuest() (r int, exists bool) {
	v := m.addprice_guest
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriceGuest clears the value of the "price_guest" field.
func (m *OccurrenceMutation) ClearPriceGuest() {
	m.price_guest = nil
	m.addprice_guest = nil
	m.clearedFields[occurrence.FieldPriceGuest] = struct{}{}
}

// PriceGuestCleared returns if the "price_guest" field was cleared in this mutation.
func (m *OccurrenceMutation) PriceGuestCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPriceGuest]
	return ok
}

// ResetPriceGuest resets all changes to the "price_guest" field.
func (m *OccurrenceMutation) ResetPriceGuest() {
	m.price_guest = nil
	m.addprice_guest = nil
	delete(m.clearedFields, occurrence.FieldPriceGuest)
}

// SetNotAvailableAfter sets the "not_available_after" field.
func (m *OccurrenceMutation) SetNotAvailableAfter(t time.Time) {
	m.not_available_after = &t
}

// NotAvailableAfter returns the value of the "not_available_after" field in the mutation.
func (m *OccurrenceMutation) NotAvailableAfter() (r time.Time, exists bool) {
	v := m.not_available_after
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAvailableAfter returns the old "not_available_after" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldNotAvailableAfter(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAvailableAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAvailableAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAvailableAfter: %w", err)
	}
	return oldValue.NotAvailableAfter, nil
}

// ClearNotAvailableAfter clears the value of the "not_available_after" field.
func (m *OccurrenceMutation) ClearNotAvailableAfter() {
	m.not_available_after = nil
	m.clearedFields[occurrence.FieldNotAvailableAfter] = struct{}{}
}

// NotAvailableAfterCleared returns if the "not_available_after" field was cleared in this mutation.
func (m *OccurrenceMutation) NotAvailableAfterCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldNotAvailableAfter]
	return ok
}

// ResetNotAvailableAfter resets all changes to the "not_available_after" field.
func (m *OccurrenceMutation) ResetNotAvailableAfter() {
	m.not_available_after = nil
	delete(m.clearedFields, occurrence.FieldNotAvailableAfter)
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *OccurrenceMutation) SetLocationID(id uuid.UUID) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *OccurrenceMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *OccurrenceMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *OccurrenceMutation) LocationID() (id uuid.UUID, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *OccurrenceMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetDishID sets the "dish" edge to the Dish entity by id.
func (m *OccurrenceMutation) SetDishID(id uuid.UUID) {
	m.dish = &id
}

// ClearDish clears the "dish" edge to the Dish entity.
func (m *OccurrenceMutation) ClearDish() {
	m.cleareddish = true
}

// DishCleared reports if the "dish" edge to the Dish entity was cleared.
func (m *OccurrenceMutation) DishCleared() bool {
	return m.cleareddish
}

// DishID returns the "dish" edge ID in the mutation.
func (m *OccurrenceMutation) DishID() (id uuid.UUID, exists bool) {
	if m.dish != nil {
		return *m.dish, true
	}
	return
}

// DishIDs returns the "dish" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DishID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) DishIDs() (ids []uuid.UUID) {
	if id := m.dish; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDish resets all changes to the "dish" edge.
func (m *OccurrenceMutation) ResetDish() {
	m.dish = nil
	m.cleareddish = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *OccurrenceMutation) AddTagIDs(ids ...string) {
	if m.tags == nil {
		m.tags = make(map[string]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *OccurrenceMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *OccurrenceMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *OccurrenceMutation) RemoveTagIDs(ids ...string) {
	if m.removedtags == nil {
		m.removedtags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *OccurrenceMutation) RemovedTagsIDs() (ids []string) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *OccurrenceMutation) TagsIDs() (ids []string) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *OccurrenceMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddSideDishIDs adds the "side_dishes" edge to the Dish entity by ids.
func (m *OccurrenceMutation) AddSideDishIDs(ids ...uuid.UUID) {
	if m.side_dishes == nil {
		m.side_dishes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.side_dishes[ids[i]] = struct{}{}
	}
}

// ClearSideDishes clears the "side_dishes" edge to the Dish entity.
func (m *OccurrenceMutation) ClearSideDishes() {
	m.clearedside_dishes = true
}

// SideDishesCleared reports if the "side_dishes" edge to the Dish entity was cleared.
func (m *OccurrenceMutation) SideDishesCleared() bool {
	return m.clearedside_dishes
}

// RemoveSideDishIDs removes the "side_dishes" edge to the Dish entity by IDs.
func (m *OccurrenceMutation) RemoveSideDishIDs(ids ...uuid.UUID) {
	if m.removedside_dishes == nil {
		m.removedside_dishes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.side_dishes, ids[i])
		m.removedside_dishes[ids[i]] = struct{}{}
	}
}

// RemovedSideDishes returns the removed IDs of the "side_dishes" edge to the Dish entity.
func (m *OccurrenceMutation) RemovedSideDishesIDs() (ids []uuid.UUID) {
	for id := range m.removedside_dishes {
		ids = append(ids, id)
	}
	return
}

// SideDishesIDs returns the "side_dishes" edge IDs in the mutation.
func (m *OccurrenceMutation) SideDishesIDs() (ids []uuid.UUID) {
	for id := range m.side_dishes {
		ids = append(ids, id)
	}
	return
}

// ResetSideDishes resets all changes to the "side_dishes" edge.
func (m *OccurrenceMutation) ResetSideDishes() {
	m.side_dishes = nil
	m.clearedside_dishes = false
	m.removedside_dishes = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *OccurrenceMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *OccurrenceMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *OccurrenceMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *OccurrenceMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *OccurrenceMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *OccurrenceMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *OccurrenceMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// Where appends a list predicates to the OccurrenceMutation builder.
func (m *OccurrenceMutation) Where(ps ...predicate.Occurrence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occurrence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occurrence).
func (m *OccurrenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.date != nil {
		fields = append(fields, occurrence.FieldDate)
	}
	if m.kj != nil {
		fields = append(fields, occurrence.FieldKj)
	}
	if m.kcal != nil {
		fields = append(fields, occurrence.FieldKcal)
	}
	if m.fat != nil {
		fields = append(fields, occurrence.FieldFat)
	}
	if m.saturated_fat != nil {
		fields = append(fields, occurrence.FieldSaturatedFat)
	}
	if m.carbohydrates != nil {
		fields = append(fields, occurrence.FieldCarbohydrates)
	}
	if m.sugar != nil {
		fields = append(fields, occurrence.FieldSugar)
	}
	if m.fiber != nil {
		fields = append(fields, occurrence.FieldFiber)
	}
	if m.protein != nil {
		fields = append(fields, occurrence.FieldProtein)
	}
	if m.salt != nil {
		fields = append(fields, occurrence.FieldSalt)
	}
	if m.price_student != nil {
		fields = append(fields, occurrence.FieldPriceStudent)
	}
	if m.price_staff != nil {
		fields = append(fields, occurrence.FieldPriceStaff)
	}
	if m.price_guest != nil {
		fields = append(fields, occurrence.FieldPriceGuest)
	}
	if m.not_available_after != nil {
		fields = append(fields, occurrence.FieldNotAvailableAfter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldDate:
		return m.Date()
	case occurrence.FieldKj:
		return m.Kj()
	case occurrence.FieldKcal:
		return m.Kcal()
	case occurrence.FieldFat:
		return m.Fat()
	case occurrence.FieldSaturatedFat:
		return m.SaturatedFat()
	case occurrence.FieldCarbohydrates:
		return m.Carbohydrates()
	case occurrence.FieldSugar:
		return m.Sugar()
	case occurrence.FieldFiber:
		return m.Fiber()
	case occurrence.FieldProtein:
		return m.Protein()
	case occurrence.FieldSalt:
		return m.Salt()
	case occurrence.FieldPriceStudent:
		return m.PriceStudent()
	case occurrence.FieldPriceStaff:
		return m.PriceStaff()
	case occurrence.FieldPriceGuest:
		return m.PriceGuest()
	case occurrence.FieldNotAvailableAfter:
		return m.NotAvailableAfter()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrence.FieldDate:
		return m.OldDate(ctx)
	case occurrence.FieldKj:
		return m.OldKj(ctx)
	case occurrence.FieldKcal:
		return m.OldKcal(ctx)
	case occurrence.FieldFat:
		return m.OldFat(ctx)
	case occurrence.FieldSaturatedFat:
		return m.OldSaturatedFat(ctx)
	case occurrence.FieldCarbohydrates:
		return m.OldCarbohydrates(ctx)
	case occurrence.FieldSugar:
		return m.OldSugar(ctx)
	case occurrence.FieldFiber:
		return m.OldFiber(ctx)
	case occurrence.FieldProtein:
		return m.OldProtein(ctx)
	case occurrence.FieldSalt:
		return m.OldSalt(ctx)
	case occurrence.FieldPriceStudent:
		return m.OldPriceStudent(ctx)
	case occurrence.FieldPriceStaff:
		return m.OldPriceStaff(ctx)
	case occurrence.FieldPriceGuest:
		return m.OldPriceGuest(ctx)
	case occurrence.FieldNotAvailableAfter:
		return m.OldNotAvailableAfter(ctx)
	}
	return nil, fmt.Errorf("unknown Occurrence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case occurrence.FieldKj:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKj(v)
		return nil
	case occurrence.FieldKcal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKcal(v)
		return nil
	case occurrence.FieldFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFat(v)
		return nil
	case occurrence.FieldSaturatedFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaturatedFat(v)
		return nil
	case occurrence.FieldCarbohydrates:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarbohydrates(v)
		return nil
	case occurrence.FieldSugar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSugar(v)
		return nil
	case occurrence.FieldFiber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiber(v)
		return nil
	case occurrence.FieldProtein:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtein(v)
		return nil
	case occurrence.FieldSalt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case occurrence.FieldPriceStudent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceStudent(v)
		return nil
	case occurrence.FieldPriceStaff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceStaff(v)
		return nil
	case occurrence.FieldPriceGuest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceGuest(v)
		return nil
	case occurrence.FieldNotAvailableAfter:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAvailableAfter(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceMutation) AddedFields() []string {
	var fields []string
	if m.addkj != nil {
		fields = append(fields, occurrence.FieldKj)
	}
	if m.addkcal != nil {
		fields = append(fields, occurrence.FieldKcal)
	}
	if m.addfat != nil {
		fields = append(fields, occurrence.FieldFat)
	}
	if m.addsaturated_fat != nil {
		fields = append(fields, occurrence.FieldSaturatedFat)
	}
	if m.addcarbohydrates != nil {
		fields = append(fields, occurrence.FieldCarbohydrates)
	}
	if m.addsugar != nil {
		fields = append(fields, occurrence.FieldSugar)
	}
	if m.addfiber != nil {
		fields = append(fields, occurrence.FieldFiber)
	}
	if m.addprotein != nil {
		fields = append(fields, occurrence.FieldProtein)
	}
	if m.addsalt != nil {
		fields = append(fields, occurrence.FieldSalt)
	}
	if m.addprice_student != nil {
		fields = append(fields, occurrence.FieldPriceStudent)
	}
	if m.addprice_staff != nil {
		fields = append(fields, occurrence.FieldPriceStaff)
	}
	if m.addprice_guest != nil {
		fields = append(fields, occurrence.FieldPriceGuest)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldKj:
		return m.AddedKj()
	case occurrence.FieldKcal:
		return m.AddedKcal()
	case occurrence.FieldFat:
		return m.AddedFat()
	case occurrence.FieldSaturatedFat:
		return m.AddedSaturatedFat()
	case occurrence.FieldCarbohydrates:
		return m.AddedCarbohydrates()
	case occurrence.FieldSugar:
		return m.AddedSugar()
	case occurrence.FieldFiber:
		return m.AddedFiber()
	case occurrence.FieldProtein:
		return m.AddedProtein()
	case occurrence.FieldSalt:
		return m.AddedSalt()
	case occurrence.FieldPriceStudent:
		return m.AddedPriceStudent()
	case occurrence.FieldPriceStaff:
		return m.AddedPriceStaff()
	case occurrence.FieldPriceGuest:
		return m.AddedPriceGuest()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldKj:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKj(v)
		return nil
	case occurrence.FieldKcal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKcal(v)
		return nil
	case occurrence.FieldFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFat(v)
		return nil
	case occurrence.FieldSaturatedFat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaturatedFat(v)
		return nil
	case occurrence.FieldCarbohydrates:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarbohydrates(v)
		return nil
	case occurrence.FieldSugar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSugar(v)
		return nil
	case occurrence.FieldFiber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFiber(v)
		return nil
	case occurrence.FieldProtein:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProtein(v)
		return nil
	case occurrence.FieldSalt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalt(v)
		return nil
	case occurrence.FieldPriceStudent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceStudent(v)
		return nil
	case occurrence.FieldPriceStaff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceStaff(v)
		return nil
	case occurrence.FieldPriceGuest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceGuest(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occurrence.FieldKj) {
		fields = append(fields, occurrence.FieldKj)
	}
	if m.FieldCleared(occurrence.FieldKcal) {
		fields = append(fields, occurrence.FieldKcal)
	}
	if m.FieldCleared(occurrence.FieldFat) {
		fields = append(fields, occurrence.FieldFat)
	}
	if m.FieldCleared(occurrence.FieldSaturatedFat) {
		fields = append(fields, occurrence.FieldSaturatedFat)
	}
	if m.FieldCleared(occurrence.FieldCarbohydrates) {
		fields = append(fields, occurrence.FieldCarbohydrates)
	}
	if m.FieldCleared(occurrence.FieldSugar) {
		fields = append(fields, occurrence.FieldSugar)
	}
	if m.FieldCleared(occurrence.FieldFiber) {
		fields = append(fields, occurrence.FieldFiber)
	}
	if m.FieldCleared(occurrence.FieldProtein) {
		fields = append(fields, occurrence.FieldProtein)
	}
	if m.FieldCleared(occurrence.FieldSalt) {
		fields = append(fields, occurrence.FieldSalt)
	}
	if m.FieldCleared(occurrence.FieldPriceStudent) {
		fields = append(fields, occurrence.FieldPriceStudent)
	}
	if m.FieldCleared(occurrence.FieldPriceStaff) {
		fields = append(fields, occurrence.FieldPriceStaff)
	}
	if m.FieldCleared(occurrence.FieldPriceGuest) {
		fields = append(fields, occurrence.FieldPriceGuest)
	}
	if m.FieldCleared(occurrence.FieldNotAvailableAfter) {
		fields = append(fields, occurrence.FieldNotAvailableAfter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceMutation) ClearField(name string) error {
	switch name {
	case occurrence.FieldKj:
		m.ClearKj()
		return nil
	case occurrence.FieldKcal:
		m.ClearKcal()
		return nil
	case occurrence.FieldFat:
		m.ClearFat()
		return nil
	case occurrence.FieldSaturatedFat:
		m.ClearSaturatedFat()
		return nil
	case occurrence.FieldCarbohydrates:
		m.ClearCarbohydrates()
		return nil
	case occurrence.FieldSugar:
		m.ClearSugar()
		return nil
	case occurrence.FieldFiber:
		m.ClearFiber()
		return nil
	case occurrence.FieldProtein:
		m.ClearProtein()
		return nil
	case occurrence.FieldSalt:
		m.ClearSalt()
		return nil
	case occurrence.FieldPriceStudent:
		m.ClearPriceStudent()
		return nil
	case occurrence.FieldPriceStaff:
		m.ClearPriceStaff()
		return nil
	case occurrence.FieldPriceGuest:
		m.ClearPriceGuest()
		return nil
	case occurrence.FieldNotAvailableAfter:
		m.ClearNotAvailableAfter()
		return nil
	}
	return fmt.Errorf("unknown Occurrence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceMutation) ResetField(name string) error {
	switch name {
	case occurrence.FieldDate:
		m.ResetDate()
		return nil
	case occurrence.FieldKj:
		m.ResetKj()
		return nil
	case occurrence.FieldKcal:
		m.ResetKcal()
		return nil
	case occurrence.FieldFat:
		m.ResetFat()
		return nil
	case occurrence.FieldSaturatedFat:
		m.ResetSaturatedFat()
		return nil
	case occurrence.FieldCarbohydrates:
		m.ResetCarbohydrates()
		return nil
	case occurrence.FieldSugar:
		m.ResetSugar()
		return nil
	case occurrence.FieldFiber:
		m.ResetFiber()
		return nil
	case occurrence.FieldProtein:
		m.ResetProtein()
		return nil
	case occurrence.FieldSalt:
		m.ResetSalt()
		return nil
	case occurrence.FieldPriceStudent:
		m.ResetPriceStudent()
		return nil
	case occurrence.FieldPriceStaff:
		m.ResetPriceStaff()
		return nil
	case occurrence.FieldPriceGuest:
		m.ResetPriceGuest()
		return nil
	case occurrence.FieldNotAvailableAfter:
		m.ResetNotAvailableAfter()
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.location != nil {
		edges = append(edges, occurrence.EdgeLocation)
	}
	if m.dish != nil {
		edges = append(edges, occurrence.EdgeDish)
	}
	if m.tags != nil {
		edges = append(edges, occurrence.EdgeTags)
	}
	if m.side_dishes != nil {
		edges = append(edges, occurrence.EdgeSideDishes)
	}
	if m.reviews != nil {
		edges = append(edges, occurrence.EdgeReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeDish:
		if id := m.dish; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case occurrence.EdgeSideDishes:
		ids := make([]ent.Value, 0, len(m.side_dishes))
		for id := range m.side_dishes {
			ids = append(ids, id)
		}
		return ids
	case occurrence.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtags != nil {
		edges = append(edges, occurrence.EdgeTags)
	}
	if m.removedside_dishes != nil {
		edges = append(edges, occurrence.EdgeSideDishes)
	}
	if m.removedreviews != nil {
		edges = append(edges, occurrence.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case occurrence.EdgeSideDishes:
		ids := make([]ent.Value, 0, len(m.removedside_dishes))
		for id := range m.removedside_dishes {
			ids = append(ids, id)
		}
		return ids
	case occurrence.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedlocation {
		edges = append(edges, occurrence.EdgeLocation)
	}
	if m.cleareddish {
		edges = append(edges, occurrence.EdgeDish)
	}
	if m.clearedtags {
		edges = append(edges, occurrence.EdgeTags)
	}
	if m.clearedside_dishes {
		edges = append(edges, occurrence.EdgeSideDishes)
	}
	if m.clearedreviews {
		edges = append(edges, occurrence.EdgeReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrence.EdgeLocation:
		return m.clearedlocation
	case occurrence.EdgeDish:
		return m.cleareddish
	case occurrence.EdgeTags:
		return m.clearedtags
	case occurrence.EdgeSideDishes:
		return m.clearedside_dishes
	case occurrence.EdgeReviews:
		return m.clearedreviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceMutation) ClearEdge(name string) error {
	switch name {
	case occurrence.EdgeLocation:
		m.ClearLocation()
		return nil
	case occurrence.EdgeDish:
		m.ClearDish()
		return nil
	}
	return fmt.Errorf("unknown Occurrence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceMutation) ResetEdge(name string) error {
	switch name {
	case occurrence.EdgeLocation:
		m.ResetLocation()
		return nil
	case occurrence.EdgeDish:
		m.ResetDish()
		return nil
	case occurrence.EdgeTags:
		m.ResetTags()
		return nil
	case occurrence.EdgeSideDishes:
		m.ResetSideDishes()
		return nil
	case occurrence.EdgeReviews:
		m.ResetReviews()
		return nil
	}
	return fmt.Errorf("unknown Occurrence edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	display_name      *string
	stars             *int
	addstars          *int
	text              *string
	created_at        *time.Time
	updated_at        *time.Time
	accepted_at       *time.Time
	clearedFields     map[string]struct{}
	occurrence        *uuid.UUID
	clearedoccurrence bool
	images            map[uuid.UUID]struct{}
	removedimages     map[uuid.UUID]struct{}
	clearedimages     bool
	done              bool
	oldValue          func(context.Context) (*Review, error)
	predicates        []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id uuid.UUID) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplayName sets the "display_name" field.
func (m *ReviewMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ReviewMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldDisplayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ReviewMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[review.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ReviewMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[review.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ReviewMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, review.FieldDisplayName)
}

// SetStars sets the "stars" field.
func (m *ReviewMutation) SetStars(i int) {
	m.stars = &i
	m.addstars = nil
}

// Stars returns the value of the "stars" field in the mutation.
func (m *ReviewMutation) Stars() (r int, exists bool) {
	v := m.stars
	if v == nil {
		return
	}
	return *v, true
}

// OldStars returns the old "stars" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldStars(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStars: %w", err)
	}
	return oldValue.Stars, nil
}

// AddStars adds i to the "stars" field.
func (m *ReviewMutation) AddStars(i int) {
	if m.addstars != nil {
		*m.addstars += i
	} else {
		m.addstars = &i
	}
}

// AddedStars returns the value that was added to the "stars" field in this mutation.
func (m *ReviewMutation) AddedStars() (r int, exists bool) {
	v := m.addstars
	if v == nil {
		return
	}
	return *v, true
}

// ResetStars resets all changes to the "stars" field.
func (m *ReviewMutation) ResetStars() {
	m.stars = nil
	m.addstars = nil
}

// SetText sets the "text" field.
func (m *ReviewMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *ReviewMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ClearText clears the value of the "text" field.
func (m *ReviewMutation) ClearText() {
	m.text = nil
	m.clearedFields[review.FieldText] = struct{}{}
}

// TextCleared returns if the "text" field was cleared in this mutation.
func (m *ReviewMutation) TextCleared() bool {
	_, ok := m.clearedFields[review.FieldText]
	return ok
}

// ResetText resets all changes to the "text" field.
func (m *ReviewMutation) ResetText() {
	m.text = nil
	delete(m.clearedFields, review.FieldText)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *ReviewMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *ReviewMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *ReviewMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[review.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *ReviewMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[review.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *ReviewMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, review.FieldAcceptedAt)
}

// SetOccurrenceID sets the "occurrence" edge to the Occurrence entity by id.
func (m *ReviewMutation) SetOccurrenceID(id uuid.UUID) {
	m.occurrence = &id
}

// ClearOccurrence clears the "occurrence" edge to the Occurrence entity.
func (m *ReviewMutation) ClearOccurrence() {
	m.clearedoccurrence = true
}

// OccurrenceCleared reports if the "occurrence" edge to the Occurrence entity was cleared.
func (m *ReviewMutation) OccurrenceCleared() bool {
	return m.clearedoccurrence
}

// OccurrenceID returns the "occurrence" edge ID in the mutation.
func (m *ReviewMutation) OccurrenceID() (id uuid.UUID, exists bool) {
	if m.occurrence != nil {
		return *m.occurrence, true
	}
	return
}

// OccurrenceIDs returns the "occurrence" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OccurrenceID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) OccurrenceIDs() (ids []uuid.UUID) {
	if id := m.occurrence; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOccurrence resets all changes to the "occurrence" edge.
func (m *ReviewMutation) ResetOccurrence() {
	m.occurrence = nil
	m.clearedoccurrence = false
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *ReviewMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *ReviewMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *ReviewMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *ReviewMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *ReviewMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ReviewMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ReviewMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.display_name != nil {
		fields = append(fields, review.FieldDisplayName)
	}
	if m.stars != nil {
		fields = append(fields, review.FieldStars)
	}
	if m.text != nil {
		fields = append(fields, review.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, review.FieldUpdatedAt)
	}
	if m.accepted_at != nil {
		fields = append(fields, review.FieldAcceptedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldDisplayName:
		return m.DisplayName()
	case review.FieldStars:
		return m.Stars()
	case review.FieldText:
		return m.Text()
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldUpdatedAt:
		return m.UpdatedAt()
	case review.FieldAcceptedAt:
		return m.AcceptedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case review.FieldStars:
		return m.OldStars(ctx)
	case review.FieldText:
		return m.OldText(ctx)
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case review.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case review.FieldStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStars(v)
		return nil
	case review.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case review.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addstars != nil {
		fields = append(fields, review.FieldStars)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldStars:
		return m.AddedStars()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldStars:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStars(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(review.FieldDisplayName) {
		fields = append(fields, review.FieldDisplayName)
	}
	if m.FieldCleared(review.FieldText) {
		fields = append(fields, review.FieldText)
	}
	if m.FieldCleared(review.FieldAcceptedAt) {
		fields = append(fields, review.FieldAcceptedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	switch name {
	case review.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case review.FieldText:
		m.ClearText()
		return nil
	case review.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case review.FieldStars:
		m.ResetStars()
		return nil
	case review.FieldText:
		m.ResetText()
		return nil
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case review.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.occurrence != nil {
		edges = append(edges, review.EdgeOccurrence)
	}
	if m.images != nil {
		edges = append(edges, review.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeOccurrence:
		if id := m.occurrence; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedimages != nil {
		edges = append(edges, review.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoccurrence {
		edges = append(edges, review.EdgeOccurrence)
	}
	if m.clearedimages {
		edges = append(edges, review.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeOccurrence:
		return m.clearedoccurrence
	case review.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeOccurrence:
		m.ClearOccurrence()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeOccurrence:
		m.ResetOccurrence()
		return nil
	case review.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	description       *string
	short_name        *string
	priority          *schema.TagPriority
	is_allergy        *bool
	clearedFields     map[string]struct{}
	occurrence        map[uuid.UUID]struct{}
	removedoccurrence map[uuid.UUID]struct{}
	clearedoccurrence bool
	done              bool
	oldValue          func(context.Context) (*Tag, error)
	predicates        []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id string) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// SetShortName sets the "short_name" field.
func (m *TagMutation) SetShortName(s string) {
	m.short_name = &s
}

// ShortName returns the value of the "short_name" field in the mutation.
func (m *TagMutation) ShortName() (r string, exists bool) {
	v := m.short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "short_name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldShortName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ClearShortName clears the value of the "short_name" field.
func (m *TagMutation) ClearShortName() {
	m.short_name = nil
	m.clearedFields[tag.FieldShortName] = struct{}{}
}

// ShortNameCleared returns if the "short_name" field was cleared in this mutation.
func (m *TagMutation) ShortNameCleared() bool {
	_, ok := m.clearedFields[tag.FieldShortName]
	return ok
}

// ResetShortName resets all changes to the "short_name" field.
func (m *TagMutation) ResetShortName() {
	m.short_name = nil
	delete(m.clearedFields, tag.FieldShortName)
}

// SetPriority sets the "priority" field.
func (m *TagMutation) SetPriority(sp schema.TagPriority) {
	m.priority = &sp
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TagMutation) Priority() (r schema.TagPriority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldPriority(ctx context.Context) (v schema.TagPriority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TagMutation) ResetPriority() {
	m.priority = nil
}

// SetIsAllergy sets the "is_allergy" field.
func (m *TagMutation) SetIsAllergy(b bool) {
	m.is_allergy = &b
}

// IsAllergy returns the value of the "is_allergy" field in the mutation.
func (m *TagMutation) IsAllergy() (r bool, exists bool) {
	v := m.is_allergy
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAllergy returns the old "is_allergy" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIsAllergy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAllergy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAllergy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAllergy: %w", err)
	}
	return oldValue.IsAllergy, nil
}

// ResetIsAllergy resets all changes to the "is_allergy" field.
func (m *TagMutation) ResetIsAllergy() {
	m.is_allergy = nil
}

// AddOccurrenceIDs adds the "occurrence" edge to the Occurrence entity by ids.
func (m *TagMutation) AddOccurrenceIDs(ids ...uuid.UUID) {
	if m.occurrence == nil {
		m.occurrence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occurrence[ids[i]] = struct{}{}
	}
}

// ClearOccurrence clears the "occurrence" edge to the Occurrence entity.
func (m *TagMutation) ClearOccurrence() {
	m.clearedoccurrence = true
}

// OccurrenceCleared reports if the "occurrence" edge to the Occurrence entity was cleared.
func (m *TagMutation) OccurrenceCleared() bool {
	return m.clearedoccurrence
}

// RemoveOccurrenceIDs removes the "occurrence" edge to the Occurrence entity by IDs.
func (m *TagMutation) RemoveOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedoccurrence == nil {
		m.removedoccurrence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occurrence, ids[i])
		m.removedoccurrence[ids[i]] = struct{}{}
	}
}

// RemovedOccurrence returns the removed IDs of the "occurrence" edge to the Occurrence entity.
func (m *TagMutation) RemovedOccurrenceIDs() (ids []uuid.UUID) {
	for id := range m.removedoccurrence {
		ids = append(ids, id)
	}
	return
}

// OccurrenceIDs returns the "occurrence" edge IDs in the mutation.
func (m *TagMutation) OccurrenceIDs() (ids []uuid.UUID) {
	for id := range m.occurrence {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrence resets all changes to the "occurrence" edge.
func (m *TagMutation) ResetOccurrence() {
	m.occurrence = nil
	m.clearedoccurrence = false
	m.removedoccurrence = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.short_name != nil {
		fields = append(fields, tag.FieldShortName)
	}
	if m.priority != nil {
		fields = append(fields, tag.FieldPriority)
	}
	if m.is_allergy != nil {
		fields = append(fields, tag.FieldIsAllergy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldShortName:
		return m.ShortName()
	case tag.FieldPriority:
		return m.Priority()
	case tag.FieldIsAllergy:
		return m.IsAllergy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldShortName:
		return m.OldShortName(ctx)
	case tag.FieldPriority:
		return m.OldPriority(ctx)
	case tag.FieldIsAllergy:
		return m.OldIsAllergy(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case tag.FieldPriority:
		v, ok := value.(schema.TagPriority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case tag.FieldIsAllergy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAllergy(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldShortName) {
		fields = append(fields, tag.FieldShortName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldShortName:
		m.ClearShortName()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldShortName:
		m.ResetShortName()
		return nil
	case tag.FieldPriority:
		m.ResetPriority()
		return nil
	case tag.FieldIsAllergy:
		m.ResetIsAllergy()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.occurrence != nil {
		edges = append(edges, tag.EdgeOccurrence)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOccurrence:
		ids := make([]ent.Value, 0, len(m.occurrence))
		for id := range m.occurrence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedoccurrence != nil {
		edges = append(edges, tag.EdgeOccurrence)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOccurrence:
		ids := make([]ent.Value, 0, len(m.removedoccurrence))
		for id := range m.removedoccurrence {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoccurrence {
		edges = append(edges, tag.EdgeOccurrence)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeOccurrence:
		return m.clearedoccurrence
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeOccurrence:
		m.ResetOccurrence()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	email         *string
	password_hash *string
	username      *string
	role          *schema.UserRole
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(sr schema.UserRole) {
	m.role = &sr
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r schema.UserRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v *schema.UserRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *UserMutation) ClearRole() {
	m.role = nil
	m.clearedFields[user.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *UserMutation) RoleCleared() bool {
	_, ok := m.clearedFields[user.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, user.FieldRole)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldUsername:
		return m.Username()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldRole:
		v, ok := value.(schema.UserRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldRole) {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
